# Author: Julien Diot juliendiot@ut-biomet.org
# 2022 The University of Tokyo
#
# Description:
# Relationship matrices calculation functions

#' Pedigree Relationship Matrix calculation
#'
#' @param ped List return by `readPedData` function
#'
#' @return matrix
#' @author Hiroyoshi Iwata, Julien Diot
pedRelMat <- function(ped) {
  logger <- logger$new("r-pedRelMat()")

  ### Check input ----
  logger$log('Check inputs ...')
  if (!is.list(ped)) {
    stop(
      "`ped` should be a list generated by `readPedData` function. ",
      "`ped` is \"",
      class(ped),
      "\""
    )
  }
  if (!identical(names(ped), c("data", "graph"))) {
    stop(
      "`ped` should be a list generated by `readPedData` function. ",
      "Therfore names of `ped` should be \"data\", \"graph\".",
      "It is: \"", paste(names(ped), collapse = '", "'),"\""
    )
  }
  if (!is.data.frame(ped$data)) {
    stop(
      "`ped` should be a list generated by `readPedData` function. ",
      "Therfore `ped$data` should be a \"data.frame\". It is: \"",
      class(ped$data),
      "\""
    )
  }
  if (!identical(colnames(ped$data), c('ind', 'parent1', 'parent2'))) {
    stop(
      "`ped` should be a list generated by `readPedData` function. ",
      'Therfore `colnames(ped$data)` should be:',
      ' "ind", "parent1", "parent2". It is: "',
      paste(colnames(ped$data), collapse = '", "'), '".'
    )
  }
  logger$log('Check inputs DONE')


  ### Create the look-up table ----
  ### this table is the same than the pedigree table with id given to the
  ### individuals according to their generation.
  logger$log('Create look-up table ...')

  lut <- as.data.frame(matrix(rep(NA, 3 * nrow(ped$data)), ncol = 3))
  colnames(lut) <- c('id', 'parent1', 'parent2')

  # initialize id of unknown parents
  lut$parent1[is.na(ped$data$parent1)] <- 0
  lut$parent2[is.na(ped$data$parent2)] <- 0
  gen <- rep(0, nrow(ped$data)) # vector of generation

  i <- 0
  while (sum(is.na(lut)) != 0 && i <= (nrow(ped$data) + 1)) {
    i <- i + 1 # to not be stuck in the loop

    # select ind with both known parents
    selector <- is.na(lut$id) & !is.na(lut$parent1) & !is.na(lut$parent2)
    if (!any(selector)) {
      # should never come here (pedigree checked in `readPedData`)
      stop("Can't create the look-up table, no Individuals with known parents")
    }

    # give id to those individuals
    lut$id[selector] <- max(c(lut$id, 0), na.rm = T) + seq(sum(selector))
    # update generation count
    gen[selector] <- max(gen) + 1

    # fill the look-up table with these new ids
    selectedId <- lut$id[selector]
    selectedNames <- ped$data$ind[selector]
    for (j in seq(sum(selector))) {
      lut$parent1[ped$data$parent1 == selectedNames[j]] <- selectedId[j]
      lut$parent2[ped$data$parent2 == selectedNames[j]] <- selectedId[j]
    }
  }
  lut$name <- ped$data$ind
  lut <- lut[order(lut$id),] # re-order the table
  logger$log('Create look-up table DONE')



  ### Calculate relationship matrix
  logger$log('Calculate relationship matrix ...')
  relMat <- matrix(NA, nrow = nrow(ped$data), ncol = nrow(ped$data))
  for (i in seq(nrow(lut))) {
    # l <- which(lut$id == i) # l is always = to i because lut is ordered.
    # p1 <- lut[l, 'parent1']
    # p2 <- lut[l, 'parent2']

    p1 <- lut$parent1[i]
    p2 <- lut$parent2[i]

    for (j in seq(i)) {
      if (j != i) {
        if (p1 != 0 & p2 != 0) {
          relMat[i, j] <- relMat[j, i] <- 0.5 * (relMat[j, p1] + relMat[j, p2])
        } else if (p1 == 0 & p2 == 0) {
          relMat[i, j] <- relMat[j, i] <- 0
        } else if (p1 == 0) {
          relMat[i, j] <- relMat[j, i] <- 0.5 * relMat[j, p2]
        } else if (p2 == 0) {
          relMat[i, j] <- relMat[j, i] <- 0.5 * relMat[j, p1]
        }
      } else {
        if (p1 != 0 & p2 != 0) {
          relMat[i, i] <- 1 + 0.5 * relMat[p1, p2]
        } else {
          relMat[i, i] <- 1
        }
      }
    }
  }
  row.names(relMat) <- colnames(relMat) <- lut$name
  # because lut is ordered, the above line is similar to:
  #   names <- sapply(seq(nrow(relMat)), function(i){lut[lut$id == i, 'name']})
  #   row.names(relMat) <- colnames(relMat) <- name


  # reset initial order
  relMat <- relMat[ped$data$ind, ped$data$ind]

  logger$log('Calculate relationship matrix DONE')

  ### output ----
  logger$log("DONE, return output.")
  return(relMat)
}





#' Genomic Relationship Matrix calculation
#'
#' @param geno `gaston::bed.matrix` return by `readGenoData` function
#'
#' @return matrix
#' @author Hiroyoshi Iwata, Julien Diot
genoRelMat <- function(geno) {
  logger <- logger$new("r-genodRelMat()")

  ### Check input ----
  logger$log('Check inputs ...')
  if (!all.equal(class(geno)[1], c('bed.matrix'))) {
    stop(
      "`geno` should be a \"bed.matrix\" generated by `readPedData` function. ",
      "`geno` is \"",
      class(geno),
      "\""
    )
  }
  logger$log('Check inputs DONE')

  # calculate genetic relationship matrix
  logger$log('Calculate genomic relationship matrix ...')
  # # the following is commented because it take too much time for "big" geno
  # X <- as.matrix(geno)
  # logger$log('Scale genomic matrix ...')
  # X_scaled <- scale(X)
  # logger$log('Scale genomic matrix DONE')
  # logger$log('Calculate crossproduct (this might take a while) ...')
  # grm <- tcrossprod(X_scaled) / ncol(X_scaled)
  # logger$log('Calculate crossproduct DONE')
  grm <- gaston::GRM(geno, autosome.only = FALSE)
  logger$log('Calculate genomic relationship matrix DONE')


  ### output ----
  logger$log("DONE, return output.")
  return(grm)

  }
