# Author: Julien Diot juliendiot@ut-biomet.org
# 2021 The University of Tokyo
#
# Description:
# Functions for running GWAS analysis


#' perform GWAS analysis
#'
#' @param data List return by `prepareDta` function
#' @param trait Chraracter of length 1, name of the trait to analyze. Could be a
#'   column name of the phenotypic file
#' @param test Which test to use. Either `"score"`,  `"wald"` or `"lrt"`. For
#'   binary phenotypes, test = `"score"` is mandatory. For more information
#'   about this parameters see: `??gaston::association.test`
#' @param fixed Number of Principal Components to include in the model with
#'   fixed effect (for test = `"wald"` or `"lrt"`). Default value is 0. For more
#'   information about this parameters see: `??gaston::association.test`
#' @param response Character of length 1, Either "quantitative" or "binary". Is
#'   the trait a quantitative or a binary phenotype? Default value is
#'   "quantitative"
#' @param thresh_maf Threshold for filtering markers. Only markers with minor
#'   allele frequency > `thresh_maf` will be kept.
#' @param thresh_callrate Threshold for filtering markers. Only markers with a
#'   callrate > `thresh_callrate` will be kept.
#'
#' @return `data.frame`
gwas <- function(data,
                 trait,
                 test,
                 fixed = 0,
                 response = "quantitative",
                 thresh_maf,
                 thresh_callrate) {
  logger <- logger$new("r-gwas()")

  ### Check inputs ----
  logger$log("Check inputs ...")

  ### `data`
  if (!is.list(data)) {
    stop(
      "`data` should be a list generated by `prepareDta` function. ",
      "`data` is \"",
      class(data),
      "\""
    )
  }
  if (!identical(names(data), c("genoData", "phenoData", "grMatrix"))) {
    stop(
      "`data` should be a list generated by `prepareDta` function. ",
      "Therfore names of `data` should be \"genoData\", \"phenoData\",",
      "\"grMatrix\". It is: \"",
      names(data),
      "\""
    )


  }
  if (!identical(class(data$genoData),
                 structure("bed.matrix", package = "gaston"))) {
    stop(
      "`data` should be a list generated by `prepareDta` function. ",
      "Therfore `data$genoData` should be a \"bed.matrix\". It is: \"",
      class(data$genoData),
      "\""
    )
  }

  if (!is.data.frame(data$phenoData)) {
    stop(
      "`data` should be a list generated by `prepareDta` function. ",
      "Therfore `data$phenoData` should be a \"data.frame\". It is: \"",
      class(data$phenoData),
      "\""
    )
  }
  if (!is.matrix(data$grMatrix)) {
    stop(
      "`data` should be a list generated by `prepareDta` function. ",
      "Therfore `data$grMatrix` should be a \"matrix\". It is: \"",
      class(data$grMatrix),
      "\""
    )
  }

  ### `trait`
  if (!is.character(trait)) {
    stop("`trait` should be a character string of length 1 ",
         "It is \"",
         class(trait),
         "\"")
  }
  if (length(trait) != 1) {
    stop(
      "`trait` should be a character string of length 1 ",
      "It's length is \"",
      length(trait),
      "\""
    )
  }
  if (!trait %in% colnames(data$phenoData)) {
    stop(
      "`trait` should correspond to a column name of the phenotypic data.",
      "`trait` is \"",
      trait,
      "\" and the columns names of the phenotypics",
      " data are: ",
      paste(colnames(data$phenoData), collapse = ", ")
    )
  }

  ### `test`
  if (!is.character(test)) {
    stop("`test` should be a character string of length 1 ",
         "It is \"",
         class(test),
         "\"")
  }
  if (length(test) != 1) {
    stop(
      "`test` should be a character string of length 1 ",
      "It's length is \"",
      length(test),
      "\""
    )
  }
  if (!test %in% c("score", "wald", "lrt")) {
    stop('`test` should correspond to "score", "wald", or "lrt". ',
         "`test` is \"",
         test)
  }

  ### `fixed`
  if (test %in% c("wald", "lrt")) {
    if (!is.numeric(fixed)) {
      stop("`fixed` should be a numeric value of length 1 ",
           "It is \"",
           class(fixed),
           "\"")
    }
    if (length(fixed) != 1) {
      stop(
        "`fixed` should be a numeric value of length 1 ",
        "It's length is \"",
        length(fixed),
        "\""
      )
    }
  }

  ### `response`
  if (!is.character(response)) {
    stop(
      "`response` should be a character string of length 1 ",
      "It is \"",
      class(response),
      "\""
    )
  }
  if (length(response) != 1) {
    stop(
      "`response` should be a character string of length 1 ",
      "It's length is \"",
      length(response),
      "\""
    )
  }
  if (!response %in% c("quantitative", "binary")) {
    stop(
      '`response` should correspond to "quantitative", or "binary". ',
      "`response` is \"",
      response
    )
  }

  ### `thresh_maf`
  if (!is.numeric(thresh_maf)) {
    stop(
      "`thresh_maf` should be a numeric value between 0 and 1 of length 1 ",
      "It is \"",
      class(thresh_maf),
      "\""
    )
  }
  if (thresh_maf < 0 || thresh_maf > 1) {
    stop(
      "`thresh_maf` should be a numeric value between 0 and 1 of length 1 ",
      "It's value is \"",
      thresh_maf,
      "\""
    )
  }

  ### `thresh_callrate`
  if (!is.numeric(thresh_callrate)) {
    stop(
      "`thresh_callrate` should be a numeric value between 0 and 1 of length 1 ",
      "It is \"",
      class(thresh_callrate),
      "\""
    )
  }
  if (thresh_callrate < 0 || thresh_callrate > 1) {
    stop(
      "`thresh_callrate` should be a numeric value between 0 and 1 of length 1 ",
      "It's value is \"",
      thresh_callrate,
      "\""
    )
  }

  logger$log("Check inputs DONE")

  ### Aggregate data in bed matrix ----
  logger$log("aggregate data in bed matrix ...")
  bm <- data$genoData
  bm@ped$pheno <- data$phenoData[, trait]
  K <- data$grMatrix
  logger$log("aggregate data in bed matrix DONE")

  ### FILTER SAMPLES ----
  # remove samples with missing phenotypic values
  logger$log("remove samples with missing phenotypic values ...")
  bm <- gaston::select.inds(bm, !is.na(pheno))
  K <- K[bm@ped$id, bm@ped$id]
  logger$log("remove samples with missing phenotypic values DONE")


  ### FILTER SNPs ----
  # keep marker with a large enough MAF (>0.05)
  # and low missing rate (callrate>0.9)
  logger$log("filter SNPs ...")
  bm <- gaston::select.snps(bm, maf > thresh_maf)
  bm <- gaston::select.snps(bm, callrate > thresh_callrate)
  logger$log("filter SNPs DONE")

  ### FIT MODEL ----

  logger$log("fit model ...")
  if (test != "score") {
    gwa <- gaston::association.test(
      bm,
      method = "lmm",
      response = response,
      test = test,
      eigenK = eigen(K),
      p = fixed
    )
  } else {
    gwa <- gaston::association.test(
      bm,
      method = "lmm",
      response = response,
      test = test,
      K = K
    )
  }
  logger$log("fit model DONE")

  logger$log("DONE, return output.")

  return(gwa)

}



#' Title
#'
#' @param vector of p-values
#' @param adj_method  correction method: "holm", "hochberg",
#' "bonferroni", "BH", "BY", "fdr", "none" (see ?p.adjust for more details)
#' @param thresh_p optional value of the threshold
#'
#' @details The method "hommel" is not implemented because it is too long to calculate.
#' @return list of two elements: "p_adj" vector of adjusted p values, "thresh_adj" the adjusted threshold (if thresh_p is preovided, NULL if not)
adjustPval <- function(p, adj_method, thresh_p = NULL){
  logger <- logger$new("r-adjustPval()")

  # check adjMethod
  logger$log("Check adj_method ...")
  if (!adj_method %in%
      c("holm", "hochberg","bonferroni", "BH", "BY", "fdr", "none")) {
    logger$log('Error: "adj_method" shoule be one of: "holm", "hochberg","bonferroni", "BH", "BY", "fdr", "none"')
    stop('Error: "adj_method" shoule be one of: "holm", "hochberg","bonferroni", "BH", "BY", "fdr", "none"')
  }
  logger$log("Check adj_method DONE")


  # P-Values adjustment
  logger$log("Adjust p-values ...")
  p_adj <- p.adjust(p,
                         method = adj_method,
                         n = length(p))
  logger$log("Adjust p-values DONE")

  if (!is.null(thresh_p)) {
    if (!adj_method == "none") {
    # get adjusted threshold
    logger$log("Adjust threshold ...")
    if (thresh_p > 1 | thresh_p < 0) {
      stop('Error: "thresh_p" should be between 0 and 1.')
    }
    thresh_adj <- uniroot(
      function(log10p){
        # accuracy is bad if we don't transform with log10
        x <- 10^(log10p)
        p.adjust(c(x, p),
                 method = adj_method,
                 n = length(p) + 1)[1] - thresh_p
      },
      c(log10(2e-12), log10(1))
    )
    thresh_adj <- 10^(thresh_adj$root)
    logger$log("Adjust threshold DONE")
    } else {
      thresh_adj <- thresh_p
    }
  } else {
    thresh_adj <- NULL
  }
  logger$log("DONE, return output")

  list("p_adj" = p_adj,
       "thresh_adj" = thresh_adj)
}
